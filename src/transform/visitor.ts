import { Path } from "./path";
import * as t from "./shapes";

export interface Visitor<S = {}> {
  a?(path: Path<t.A>, state: S): void;
  animate?(path: Path<t.Animate>, state: S): void;
  animateMotion?(path: Path<t.AnimateMotion>, state: S): void;
  animateTransform?(path: Path<t.AnimateTransform>, state: S): void;
  circle?(path: Path<t.Circle>, state: S): void;
  clipPath?(path: Path<t.ClipPath>, state: S): void;
  colorProfile?(path: Path<t.ColorProfile>, state: S): void;
  defs?(path: Path<t.Defs>, state: S): void;
  desc?(path: Path<t.Desc>, state: S): void;
  ellipse?(path: Path<t.Ellipse>, state: S): void;
  feBlend?(path: Path<t.FeBlend>, state: S): void;
  feColorMatrix?(path: Path<t.FeColorMatrix>, state: S): void;
  feComponentTransfer?(path: Path<t.FeComponentTransfer>, state: S): void;
  feComposite?(path: Path<t.FeComposite>, state: S): void;
  feConvolveMatrix?(path: Path<t.FeConvolveMatrix>, state: S): void;
  feDiffuseLighting?(path: Path<t.FeDiffuseLighting>, state: S): void;
  feDisplacementMap?(path: Path<t.FeDisplacementMap>, state: S): void;
  feDistantLight?(path: Path<t.FeDistantLight>, state: S): void;
  feFlood?(path: Path<t.FeFlood>, state: S): void;
  feFuncA?(path: Path<t.FeFuncA>, state: S): void;
  feFuncB?(path: Path<t.FeFuncB>, state: S): void;
  feFuncG?(path: Path<t.FeFuncG>, state: S): void;
  feFuncR?(path: Path<t.FeFuncR>, state: S): void;
  feGaussianBlur?(path: Path<t.FeGaussianBlur>, state: S): void;
  feImage?(path: Path<t.FeImage>, state: S): void;
  feMerge?(path: Path<t.FeMerge>, state: S): void;
  feMergeNode?(path: Path<t.FeMergeNode>, state: S): void;
  feMorphology?(path: Path<t.FeMorphology>, state: S): void;
  feOffset?(path: Path<t.FeOffset>, state: S): void;
  fePointLight?(path: Path<t.FePointLight>, state: S): void;
  feSpecularLighting?(path: Path<t.FeSpecularLighting>, state: S): void;
  feSpotLight?(path: Path<t.FeSpotLight>, state: S): void;
  feTile?(path: Path<t.FeTile>, state: S): void;
  feTurbulence?(path: Path<t.FeTurbulence>, state: S): void;
  filter?(path: Path<t.Filter>, state: S): void;
  foreignObject?(path: Path<t.ForeignObject>, state: S): void;
  g?(path: Path<t.G>, state: S): void;
  image?(path: Path<t.Image>, state: S): void;
  line?(path: Path<t.Line>, state: S): void;
  linearGradient?(path: Path<t.LinearGradient>, state: S): void;
  marker?(path: Path<t.Marker>, state: S): void;
  mask?(path: Path<t.Mask>, state: S): void;
  metadata?(path: Path<t.Metadata>, state: S): void;
  mpath?(path: Path<t.Mpath>, state: S): void;
  path?(path: Path<t.Path>, state: S): void;
  pattern?(path: Path<t.Pattern>, state: S): void;
  polygon?(path: Path<t.Polygon>, state: S): void;
  polyline?(path: Path<t.Polyline>, state: S): void;
  radialGradient?(path: Path<t.RadialGradient>, state: S): void;
  rect?(path: Path<t.Rect>, state: S): void;
  script?(path: Path<t.Script>, state: S): void;
  set?(path: Path<t.Set>, state: S): void;
  stop?(path: Path<t.Stop>, state: S): void;
  style?(path: Path<t.Style>, state: S): void;
  svg?(path: Path<t.Svg>, state: S): void;
  switch?(path: Path<t.Switch>, state: S): void;
  symbol?(path: Path<t.SVGSymbol>, state: S): void;
  text?(path: Path<t.Text>, state: S): void;
  textPath?(path: Path<t.TextPath>, state: S): void;
  title?(path: Path<t.Title>, state: S): void;
  tspan?(path: Path<t.TSpan>, state: S): void;
  use?(path: Path<t.Use>, state: S): void;
  view?(path: Path<t.View>, state: S): void;
}
